from __future__ import annotations
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import TYPE_CHECKING, override
from ._error import (
    EmptyChamberError,
    InsufficientItemsError,
    InvalidActionError
)

if TYPE_CHECKING: 
    from .board import BuckshotEngine

@dataclass
class ActionResult:
    """Result after a sucessful Action"""
    end_turn: bool = True
    game_over: bool = False
    skip_turn: bool = False
    response: str = ""

class Action(ABC):
    def __init__(self, board: BuckshotEngine):
        self.board = board

    @abstractmethod
    def execute(self) -> ActionResult:
        pass

# Failed cases: 
# - Empty chamber (should never happen)
class UseGunAction(Action):
    @override
    def execute(self):
        shell = self.board.shotgun.eject()
        game_over = False
        skip_turn = False

        if shell is None:
            raise EmptyChamberError()

        if shell is True:
            self.board.target.health -= self.board.shotgun.damage
            game_over = self.board.target.health <= 0

        if shell is False and self.board.target is self.board.actor:
            skip_turn = True

        self.board.shotgun.damage = 1
        return ActionResult(skip_turn=skip_turn, game_over=game_over)

class ItemAction(Action, ABC):
    def _consume_item(self, item: str):
        if not self.board.actor.inventory.has_item(item):
            raise InsufficientItemsError(item)
        self.board.actor.inventory.items[item] -= 1

# Failed cases: 
# - Empty chamber (should never happen)
# - Does not have item
class UseMagnifierAction(ItemAction):
    @override
    def execute(self):
        shell = self.board.shotgun.peek()
        if shell is None:
            raise EmptyChamberError()

        self._consume_item("magnifier")
        response = f"Current shell is {"Live" if shell else "Blank"}"
        return ActionResult(end_turn=False, response=response)

# Failed cases: 
# - Empty chamber (should never happen)
# - Does not have item
class UseBeerAction(ItemAction):
    @override
    def execute(self):
        shell = self.board.shotgun.eject()
        if shell is None:
            raise EmptyChamberError()

        self._consume_item("beer")
        response = f"Current ejected shell is {"Live" if shell else "Blank"}"
        return ActionResult(end_turn=False, response=response)

# Failed cases: 
# - Does not have item
class UseHandsawAction(ItemAction):
    @override
    def execute(self):
        self._consume_item("handsaw")
        self.board.shotgun.cutoff()
        return ActionResult(
            end_turn=False, 
            response=f"Doubled shotgun damage, current damage is: {self.board.shotgun.damage}."
        )

# Failed cases: 
# - Does not have item
# - User is at full health
class UseCigaretteAction(ItemAction):
    @override
    def execute(self):
        if self.board.actor.health >= self.board.stage.health_cap:
            raise InvalidActionError("Already at full health")

        self._consume_item("cigarette")
        self.board.actor.health += 1
        return ActionResult(end_turn=False, response="Healed 1 health.")

# Failed cases:
# - Does not have item
# - Current target turn has been skipped (use more than 1 handcuff)
class UseHandcuffAction(ItemAction):
    @override
    def execute(self):
        if not self.board.target.turn:
            raise InvalidActionError("Target's turn already skipped")

        self._consume_item("handcuff")
        self.board.target.turn = False
        return ActionResult(end_turn=False, response="Target's next turn will be skipped")
